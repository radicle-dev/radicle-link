// This file is part of radicle-link
// <https://github.com/radicle-dev/radicle-link>
//
// Copyright (C) 2019-2020 The Radicle Team <dev@radicle.xyz>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 3 or
// later as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

use std::net::SocketAddr;

use librad::{
    git::{identities, Urn},
    net::peer::PeerApi,
    peer::PeerId,
};

use crate::{guess_user, Error, Project};

/// An event generated by the seed node.
#[derive(Debug, Clone)]
pub enum Event {
    /// The seed node is listening for peer connections.
    Listening(SocketAddr),
    /// A peer has connected.
    PeerConnected {
        peer_id: PeerId,
        urn: Option<Urn>,
        name: Option<String>,
    },
    /// A peer has disconnected.
    PeerDisconnected(PeerId),
    /// A project has been tracked from a peer.
    ProjectTracked(Project, PeerId),
}

impl Event {
    pub(crate) async fn peer_connected(peer_id: PeerId, api: &PeerApi) -> Result<Self, Error> {
        let user = self::guess_user(peer_id, api).await?;
        let user = user.as_ref();

        Ok(Self::PeerConnected {
            peer_id,
            urn: user.map(|u| u.urn()),
            name: user.map(|u| u.doc.payload.subject.name.to_string()),
        })
    }

    pub(crate) async fn project_tracked(
        urn: Urn,
        provider: PeerId,
        api: &PeerApi,
    ) -> Result<Self, Error> {
        let proj = api
            .with_storage({
                let urn = urn.clone();
                move |s| identities::project::get(&s, &urn)
            })
            .await??;

        proj.ok_or(Error::NoSuchUrn(urn))
            .map(|proj| Event::ProjectTracked(Project::from(proj), provider))
    }
}
