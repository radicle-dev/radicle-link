// This file is part of radicle-link
// <https://github.com/radicle-dev/radicle-link>
//
// Copyright (C) 2019-2020 The Radicle Team <dev@radicle.xyz>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 3 or
// later as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

use std::net::SocketAddr;

use librad::{meta::project::ProjectInfo, net::peer::PeerApi, peer::PeerId, uri::RadUrn};

use crate::{guess_user, Error, Project, Signer};

/// A peer with optional user metadata.
#[derive(Clone, Debug)]
pub struct User {
    pub peer_id: PeerId,
    pub urn: Option<RadUrn>,
    pub name: Option<String>,
}

impl User {
    async fn guess_from_peer(api: &PeerApi<Signer>, peer_id: PeerId) -> Result<Self, Error> {
        let mut user = Self {
            peer_id,
            name: None,
            urn: None,
        };

        if let Some(u) = self::guess_user(peer_id, api).await? {
            user.name = Some(u.name().to_string());
            user.urn = Some(u.urn());
        }

        Ok(user)
    }
}

/// An event generated by the seed node.
#[derive(Clone, Debug)]
pub enum Event {
    /// The seed node is listening for peer connections.
    Listening(SocketAddr),
    /// A peer has connected.
    PeerConnected(User),
    /// A peer has disconnected.
    PeerDisconnected(PeerId),
    /// A project has been tracked from a peer.
    ProjectTracked(Project, User),
}

impl Event {
    pub(crate) async fn peer_connected(
        peer_id: PeerId,
        api: &PeerApi<Signer>,
    ) -> Result<Self, Error> {
        Ok(Self::PeerConnected(
            User::guess_from_peer(api, peer_id).await?,
        ))
    }

    pub(crate) async fn project_tracked(
        urn: RadUrn,
        provider: PeerId,
        api: &PeerApi<Signer>,
    ) -> Result<Self, Error> {
        Ok(api
            .with_storage(move |storage| {
                let project = storage.metadata_of::<ProjectInfo, _>(&urn, provider)?;
                let user = storage.get_rad_self_of(&urn, provider)?;
                Ok::<_, Error>(Event::ProjectTracked(
                    Project {
                        urn: urn.clone(),
                        maintainers: project.maintainers().clone(),
                        name: project.name().to_owned(),
                        description: project.description().to_owned(),
                    },
                    User {
                        peer_id: provider,
                        name: Some(user.name().to_string()),
                        urn: Some(user.urn()),
                    },
                ))
            })
            .await??)
    }
}
